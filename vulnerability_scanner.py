import argparse
import concurrent.futures
import logging
import subprocess
import sys
import time
import nmap

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Common vulnerable ports based on historical data
common_vulnerable_ports = [21, 22, 23, 25, 53, 80, 110, 139, 143, 443, 445, 465, 993, 995, 1723, 3306, 3389, 5900, 8080, 8443]

def install_missing_modules():
    """Install missing Python modules using pip."""
    required_modules = ['nmap']
    missing_modules = [module for module in required_modules if module not in sys.modules]

    if missing_modules:
        print("The following required modules are missing: ", missing_modules)
        print("Attempting to install them...")

        for module in missing_modules:
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", module])
                print(f"Successfully installed {module}.")
            except subprocess.CalledProcessError:
                print(f"Failed to install {module}. Please install it manually.")
                sys.exit(1)

def port_scan(subdomain):
    """Perform port scanning for a subdomain."""
    try:
        nm = nmap.PortScanner()
        nm.scan(subdomain, arguments=f'-Pn -T4 -p{",".join(map(str, common_vulnerable_ports))}', timeout=100)  # Set timeout to 100 seconds
        open_ports = []
        for host in nm.all_hosts():
            for proto in nm[host].all_protocols():
                ports = nm[host][proto].keys()
                for port in ports:
                    if nm[host][proto][port]['state'] == 'open':
                        open_ports.append(f"{host}:{port}")
        return open_ports
    except Exception as e:
        logger.error(f"Error scanning {subdomain}: {e}")
        return None

def service_detection(subdomain, open_ports):
    """Detect services running on open ports."""
    services = {}
    for port in open_ports:
        port_number = port.split(':')[1]
        try:
            service = subprocess.getoutput(f"nmap -sV -p {port_number} {subdomain} | grep 'open' | awk '{{print $3}}'")
            services[port] = service
        except Exception as e:
            logger.error(f"Error detecting service for {subdomain} ({port}): {e}")
    return services

def vulnerability_scanning(subdomain, services):
    """Perform vulnerability scanning based on detected services."""
    vulnerabilities = {}
    for port, service in services.items():
        if 'metasploit' in service.lower():  # Example check for Metasploit services
            # Perform vulnerability scanning using Metasploit or other tools
            vulnerability_scan_results = f"Vulnerabilities found for {subdomain} ({port}): ..."
            vulnerabilities[subdomain] = vulnerability_scan_results
    return vulnerabilities

def write_results_to_file(results, filename):
    """Write scan results to a file."""
    with open(filename, 'w') as file:
        for subdomain, result in results.items():
            file.write(f"{subdomain}:\n")
            file.write(f"{result}\n\n")

def scan_subdomain(subdomain):
    """Scan a single subdomain for vulnerabilities."""
    open_ports = port_scan(subdomain)
    if open_ports is not None:
        services = service_detection(subdomain, open_ports)
        vulnerabilities = vulnerability_scanning(subdomain, services)
        return subdomain, open_ports, services, vulnerabilities
    else:
        return None

def main(subdomains_file):
    """Main function to orchestrate the scanning process."""
    # Install missing modules
    install_missing_modules()

    # Read subdomains from subdomains_file
    with open(subdomains_file, 'r') as file:
        subdomains = file.read().splitlines()

    # Asynchronously scan each subdomain
    with concurrent.futures.ThreadPoolExecutor() as executor:
        future_to_subdomain = {executor.submit(scan_subdomain, subdomain): subdomain for subdomain in subdomains}
        open_ports_results = {}
        services_results = {}
        vulnerabilities_results = {}
        for future in concurrent.futures.as_completed(future_to_subdomain):
            subdomain = future_to_subdomain[future]
            try:
                result = future.result()
                if result is not None:
                    subdomain, open_ports, services, vulnerabilities = result
                    open_ports_results[subdomain] = open_ports
                    services_results[subdomain] = services
                    vulnerabilities_results[subdomain] = vulnerabilities
                    logger.info(f"Scanned {subdomain} successfully.")
            except Exception as e:
                logger.error(f"Error scanning {subdomain}: {e}")

    # Write results to files
    write_results_to_file(open_ports_results, 'open_ports.txt')
    write_results_to_file(services_results, 'services.txt')
    write_results_to_file(vulnerabilities_results, 'vulnerabilities.txt')

if __name__ == "__main__":
    # Set up argument parser for input validation
    parser = argparse.ArgumentParser(description='Scan subdomains for vulnerabilities.')
    parser.add_argument('subdomains_file', type=str, help='Path to file containing subdomains')
    args = parser.parse_args()

    # Main function call
    main(args.subdomains_file)
